{
  "version": 3,
  "sources": ["../../@radix-ui/react-radio-group/dist/packages/react/radio-group/src/index.ts", "../../@radix-ui/react-radio-group/dist/packages/react/radio-group/src/RadioGroup.tsx", "../../@radix-ui/react-radio-group/dist/packages/react/radio-group/src/Radio.tsx"],
  "sourcesContent": ["export {\n  createRadioGroupScope,\n  //\n  RadioGroup,\n  RadioGroupItem,\n  RadioGroupIndicator,\n  //\n  Root,\n  Item,\n  Indicator,\n} from './RadioGroup';\nexport type { RadioGroupProps, RadioGroupItemProps, RadioGroupIndicatorProps } from './RadioGroup';\n", "import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport * as RovingFocusGroup from '@radix-ui/react-roving-focus';\nimport { createRovingFocusGroupScope } from '@radix-ui/react-roving-focus';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useDirection } from '@radix-ui/react-direction';\nimport { Radio, RadioIndicator, createRadioScope } from './Radio';\n\nimport type * as Radix from '@radix-ui/react-primitive';\nimport type { Scope } from '@radix-ui/react-context';\n\nconst ARROW_KEYS = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];\n\n/* -------------------------------------------------------------------------------------------------\n * RadioGroup\n * -----------------------------------------------------------------------------------------------*/\nconst RADIO_GROUP_NAME = 'RadioGroup';\n\ntype ScopedProps<P> = P & { __scopeRadioGroup?: Scope };\nconst [createRadioGroupContext, createRadioGroupScope] = createContextScope(RADIO_GROUP_NAME, [\n  createRovingFocusGroupScope,\n  createRadioScope,\n]);\nconst useRovingFocusGroupScope = createRovingFocusGroupScope();\nconst useRadioScope = createRadioScope();\n\ntype RadioGroupContextValue = {\n  name?: string;\n  required: boolean;\n  disabled: boolean;\n  value?: string;\n  onValueChange(value: string): void;\n};\n\nconst [RadioGroupProvider, useRadioGroupContext] =\n  createRadioGroupContext<RadioGroupContextValue>(RADIO_GROUP_NAME);\n\ntype RadioGroupElement = React.ElementRef<typeof Primitive.div>;\ntype RovingFocusGroupProps = Radix.ComponentPropsWithoutRef<typeof RovingFocusGroup.Root>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface RadioGroupProps extends PrimitiveDivProps {\n  name?: RadioGroupContextValue['name'];\n  required?: Radix.ComponentPropsWithoutRef<typeof Radio>['required'];\n  disabled?: Radix.ComponentPropsWithoutRef<typeof Radio>['disabled'];\n  dir?: RovingFocusGroupProps['dir'];\n  orientation?: RovingFocusGroupProps['orientation'];\n  loop?: RovingFocusGroupProps['loop'];\n  defaultValue?: string;\n  value?: RadioGroupContextValue['value'];\n  onValueChange?: RadioGroupContextValue['onValueChange'];\n}\n\nconst RadioGroup = React.forwardRef<RadioGroupElement, RadioGroupProps>(\n  (props: ScopedProps<RadioGroupProps>, forwardedRef) => {\n    const {\n      __scopeRadioGroup,\n      name,\n      defaultValue,\n      value: valueProp,\n      required = false,\n      disabled = false,\n      orientation,\n      dir,\n      loop = true,\n      onValueChange,\n      ...groupProps\n    } = props;\n    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeRadioGroup);\n    const direction = useDirection(dir);\n    const [value, setValue] = useControllableState({\n      prop: valueProp,\n      defaultProp: defaultValue,\n      onChange: onValueChange,\n    });\n\n    return (\n      <RadioGroupProvider\n        scope={__scopeRadioGroup}\n        name={name}\n        required={required}\n        disabled={disabled}\n        value={value}\n        onValueChange={setValue}\n      >\n        <RovingFocusGroup.Root\n          asChild\n          {...rovingFocusGroupScope}\n          orientation={orientation}\n          dir={direction}\n          loop={loop}\n        >\n          <Primitive.div\n            role=\"radiogroup\"\n            aria-required={required}\n            aria-orientation={orientation}\n            data-disabled={disabled ? '' : undefined}\n            dir={direction}\n            {...groupProps}\n            ref={forwardedRef}\n          />\n        </RovingFocusGroup.Root>\n      </RadioGroupProvider>\n    );\n  }\n);\n\nRadioGroup.displayName = RADIO_GROUP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * RadioGroupItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_NAME = 'RadioGroupItem';\n\ntype RadioGroupItemElement = React.ElementRef<typeof Radio>;\ntype RadioProps = Radix.ComponentPropsWithoutRef<typeof Radio>;\ninterface RadioGroupItemProps extends Omit<RadioProps, 'onCheck' | 'name'> {\n  value: string;\n}\n\nconst RadioGroupItem = React.forwardRef<RadioGroupItemElement, RadioGroupItemProps>(\n  (props: ScopedProps<RadioGroupItemProps>, forwardedRef) => {\n    const { __scopeRadioGroup, disabled, ...itemProps } = props;\n    const context = useRadioGroupContext(ITEM_NAME, __scopeRadioGroup);\n    const isDisabled = context.disabled || disabled;\n    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeRadioGroup);\n    const radioScope = useRadioScope(__scopeRadioGroup);\n    const ref = React.useRef<React.ElementRef<typeof Radio>>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    const checked = context.value === itemProps.value;\n    const isArrowKeyPressedRef = React.useRef(false);\n\n    React.useEffect(() => {\n      const handleKeyDown = (event: KeyboardEvent) => {\n        if (ARROW_KEYS.includes(event.key)) {\n          isArrowKeyPressedRef.current = true;\n        }\n      };\n      const handleKeyUp = () => (isArrowKeyPressedRef.current = false);\n      document.addEventListener('keydown', handleKeyDown);\n      document.addEventListener('keyup', handleKeyUp);\n      return () => {\n        document.removeEventListener('keydown', handleKeyDown);\n        document.removeEventListener('keyup', handleKeyUp);\n      };\n    }, []);\n\n    return (\n      <RovingFocusGroup.Item\n        asChild\n        {...rovingFocusGroupScope}\n        focusable={!isDisabled}\n        active={checked}\n      >\n        <Radio\n          disabled={isDisabled}\n          required={context.required}\n          checked={checked}\n          {...radioScope}\n          {...itemProps}\n          name={context.name}\n          ref={composedRefs}\n          onCheck={() => context.onValueChange(itemProps.value)}\n          onKeyDown={composeEventHandlers((event) => {\n            // According to WAI ARIA, radio groups don't activate items on enter keypress\n            if (event.key === 'Enter') event.preventDefault();\n          })}\n          onFocus={composeEventHandlers(itemProps.onFocus, () => {\n            /**\n             * Our `RovingFocusGroup` will focus the radio when navigating with arrow keys\n             * and we need to \"check\" it in that case. We click it to \"check\" it (instead\n             * of updating `context.value`) so that the radio change event fires.\n             */\n            if (isArrowKeyPressedRef.current) ref.current?.click();\n          })}\n        />\n      </RovingFocusGroup.Item>\n    );\n  }\n);\n\nRadioGroupItem.displayName = ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * RadioGroupIndicator\n * -----------------------------------------------------------------------------------------------*/\n\nconst INDICATOR_NAME = 'RadioGroupIndicator';\n\ntype RadioGroupIndicatorElement = React.ElementRef<typeof RadioIndicator>;\ntype RadioIndicatorProps = Radix.ComponentPropsWithoutRef<typeof RadioIndicator>;\ninterface RadioGroupIndicatorProps extends RadioIndicatorProps {}\n\nconst RadioGroupIndicator = React.forwardRef<RadioGroupIndicatorElement, RadioGroupIndicatorProps>(\n  (props: ScopedProps<RadioGroupIndicatorProps>, forwardedRef) => {\n    const { __scopeRadioGroup, ...indicatorProps } = props;\n    const radioScope = useRadioScope(__scopeRadioGroup);\n    return <RadioIndicator {...radioScope} {...indicatorProps} ref={forwardedRef} />;\n  }\n);\n\nRadioGroupIndicator.displayName = INDICATOR_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\nconst Root = RadioGroup;\nconst Item = RadioGroupItem;\nconst Indicator = RadioGroupIndicator;\n\nexport {\n  createRadioGroupScope,\n  //\n  RadioGroup,\n  RadioGroupItem,\n  RadioGroupIndicator,\n  //\n  Root,\n  Item,\n  Indicator,\n};\nexport type { RadioGroupProps, RadioGroupItemProps, RadioGroupIndicatorProps };\n", "import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useSize } from '@radix-ui/react-use-size';\nimport { usePrevious } from '@radix-ui/react-use-previous';\nimport { Presence } from '@radix-ui/react-presence';\nimport { Primitive } from '@radix-ui/react-primitive';\n\nimport type * as Radix from '@radix-ui/react-primitive';\nimport type { Scope } from '@radix-ui/react-context';\n\n/* -------------------------------------------------------------------------------------------------\n * Radio\n * -----------------------------------------------------------------------------------------------*/\n\nconst RADIO_NAME = 'Radio';\n\ntype ScopedProps<P> = P & { __scopeRadio?: Scope };\nconst [createRadioContext, createRadioScope] = createContextScope(RADIO_NAME);\n\ntype RadioContextValue = { checked: boolean; disabled?: boolean };\nconst [RadioProvider, useRadioContext] = createRadioContext<RadioContextValue>(RADIO_NAME);\n\ntype RadioElement = React.ElementRef<typeof Primitive.button>;\ntype PrimitiveButtonProps = Radix.ComponentPropsWithoutRef<typeof Primitive.button>;\ninterface RadioProps extends PrimitiveButtonProps {\n  checked?: boolean;\n  required?: boolean;\n  onCheck?(): void;\n}\n\nconst Radio = React.forwardRef<RadioElement, RadioProps>(\n  (props: ScopedProps<RadioProps>, forwardedRef) => {\n    const {\n      __scopeRadio,\n      name,\n      checked = false,\n      required,\n      disabled,\n      value = 'on',\n      onCheck,\n      ...radioProps\n    } = props;\n    const [button, setButton] = React.useState<HTMLButtonElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setButton(node));\n    const hasConsumerStoppedPropagationRef = React.useRef(false);\n    // We set this to true by default so that events bubble to forms without JS (SSR)\n    const isFormControl = button ? Boolean(button.closest('form')) : true;\n\n    return (\n      <RadioProvider scope={__scopeRadio} checked={checked} disabled={disabled}>\n        <Primitive.button\n          type=\"button\"\n          role=\"radio\"\n          aria-checked={checked}\n          data-state={getState(checked)}\n          data-disabled={disabled ? '' : undefined}\n          disabled={disabled}\n          value={value}\n          {...radioProps}\n          ref={composedRefs}\n          onClick={composeEventHandlers(props.onClick, (event) => {\n            // radios cannot be unchecked so we only communicate a checked state\n            if (!checked) onCheck?.();\n            if (isFormControl) {\n              hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();\n              // if radio is in a form, stop propagation from the button so that we only propagate\n              // one click event (from the input). We propagate changes from an input so that native\n              // form validation works and form events reflect radio updates.\n              if (!hasConsumerStoppedPropagationRef.current) event.stopPropagation();\n            }\n          })}\n        />\n        {isFormControl && (\n          <BubbleInput\n            control={button}\n            bubbles={!hasConsumerStoppedPropagationRef.current}\n            name={name}\n            value={value}\n            checked={checked}\n            required={required}\n            disabled={disabled}\n            // We transform because the input is absolutely positioned but we have\n            // rendered it **after** the button. This pulls it back to sit on top\n            // of the button.\n            style={{ transform: 'translateX(-100%)' }}\n          />\n        )}\n      </RadioProvider>\n    );\n  }\n);\n\nRadio.displayName = RADIO_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * RadioIndicator\n * -----------------------------------------------------------------------------------------------*/\n\nconst INDICATOR_NAME = 'RadioIndicator';\n\ntype RadioIndicatorElement = React.ElementRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = Radix.ComponentPropsWithoutRef<typeof Primitive.span>;\nexport interface RadioIndicatorProps extends PrimitiveSpanProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst RadioIndicator = React.forwardRef<RadioIndicatorElement, RadioIndicatorProps>(\n  (props: ScopedProps<RadioIndicatorProps>, forwardedRef) => {\n    const { __scopeRadio, forceMount, ...indicatorProps } = props;\n    const context = useRadioContext(INDICATOR_NAME, __scopeRadio);\n    return (\n      <Presence present={forceMount || context.checked}>\n        <Primitive.span\n          data-state={getState(context.checked)}\n          data-disabled={context.disabled ? '' : undefined}\n          {...indicatorProps}\n          ref={forwardedRef}\n        />\n      </Presence>\n    );\n  }\n);\n\nRadioIndicator.displayName = INDICATOR_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype InputProps = Radix.ComponentPropsWithoutRef<'input'>;\ninterface BubbleInputProps extends Omit<InputProps, 'checked'> {\n  checked: boolean;\n  control: HTMLElement | null;\n  bubbles: boolean;\n}\n\nconst BubbleInput = (props: BubbleInputProps) => {\n  const { control, checked, bubbles = true, ...inputProps } = props;\n  const ref = React.useRef<HTMLInputElement>(null);\n  const prevChecked = usePrevious(checked);\n  const controlSize = useSize(control);\n\n  // Bubble checked change to parents (e.g form change event)\n  React.useEffect(() => {\n    const input = ref.current!;\n    const inputProto = window.HTMLInputElement.prototype;\n    const descriptor = Object.getOwnPropertyDescriptor(inputProto, 'checked') as PropertyDescriptor;\n    const setChecked = descriptor.set;\n    if (prevChecked !== checked && setChecked) {\n      const event = new Event('click', { bubbles });\n      setChecked.call(input, checked);\n      input.dispatchEvent(event);\n    }\n  }, [prevChecked, checked, bubbles]);\n\n  return (\n    <input\n      type=\"radio\"\n      aria-hidden\n      defaultChecked={checked}\n      {...inputProps}\n      tabIndex={-1}\n      ref={ref}\n      style={{\n        ...props.style,\n        ...controlSize,\n        position: 'absolute',\n        pointerEvents: 'none',\n        opacity: 0,\n        margin: 0,\n      }}\n    />\n  );\n};\n\nfunction getState(checked: boolean) {\n  return checked ? 'checked' : 'unchecked';\n}\n\nexport {\n  createRadioScope,\n  //\n  Radio,\n  RadioIndicator,\n};\nexport type { RadioProps };\n"],
  "mappings": "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",
  "names": ["RADIO_NAME", "createRadioContext", "createRadioScope", "createContextScope", "RadioProvider", "useRadioContext", "Radio", "React", "props", "forwardedRef", "radioProps", "button", "setButton", "composedRefs", "useComposedRefs", "node", "hasConsumerStoppedPropagationRef", "isFormControl", "Boolean", "closest", "$8Wolv$createElement", "__scopeRadio", "checked", "getState", "disabled", "undefined", "composeEventHandlers", "onClick", "event", "onCheck", "current", "isPropagationStopped", "stopPropagation", "transform", "INDICATOR_NAME", "RadioIndicator", "indicatorProps", "context", "forceMount", "BubbleInput", "inputProps", "ref", "prevChecked", "usePrevious", "controlSize", "useSize", "control", "input", "inputProto", "window", "HTMLInputElement", "prototype", "descriptor", "Object", "getOwnPropertyDescriptor", "setChecked", "set", "Event", "call", "dispatchEvent", "bubbles", "style", "position", "pointerEvents", "opacity", "margin", "ARROW_KEYS", "RADIO_GROUP_NAME", "createRadioGroupContext", "createRadioGroupScope", "createRovingFocusGroupScope", "useRovingFocusGroupScope", "useRadioScope", "RadioGroupProvider", "useRadioGroupContext", "RadioGroup", "value", "valueProp", "groupProps", "rovingFocusGroupScope", "__scopeRadioGroup", "direction", "useDirection", "dir", "setValue", "useControllableState", "prop", "defaultProp", "defaultValue", "onChange", "onValueChange", "required", "orientation", "ITEM_NAME", "RadioGroupItem", "itemProps", "isDisabled", "radioScope", "isArrowKeyPressedRef", "handleKeyDown", "includes", "key", "handleKeyUp", "document", "addEventListener", "removeEventListener", "name", "preventDefault", "onFocus", "click", "RadioGroupIndicator", "Root", "Item", "Indicator"]
}
